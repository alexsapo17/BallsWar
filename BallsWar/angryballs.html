<!DOCTYPE html>
<html>
<head>
  <title>Mini Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
  <style>
    body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; background: #000; }
  </style>
</head>
<body>
  <script>
    var config = {
      type: Phaser.AUTO,
      width: 640,
      height: 340,
      backgroundColor: "#ccc", // Imposta lo sfondo a un colore visibile
      physics: {
        default: 'arcade',
        arcade: { gravity: { y: 300 }, debug: true }
      },
      scene: {
        preload: preload,
        create: create,
        update: update
      }
    };

    var game = new Phaser.Game(config);
    var ball;
    var targets = [];
    var obstacles = [];
    var pointer;
    var line;
    var trajectory;
    var isDragging = false;
    var scoreText;
    var score = 0;
    var level = 1;
    var shouldReset = false;
    var scene;

  

    function preload() {
      this.load.image('ball', 'ball.png');
      this.load.image('target', 'target.png');
      this.load.image('obstacle', 'obstacle.png');
    }
    function create() {
  this.cameras.main.setBackgroundColor('#CCC');  // Imposta il colore di sfondo
  scene = this;
  trajectory = this.add.graphics({ lineStyle: { color: 0x00ff00, width: 2 } });

  ball = this.physics.add.sprite(100, 200, 'ball');
  addColliders(this);
  // La fionda ora viene posizionata nella stessa posizione della pallina
  line = this.add.line(0.1,0.2,0.1,0.2,0.1,0.2, 0xffffff).setLineWidth(2, 8);
  ball.setVelocity(0, 0);
  ball.setInteractive();
  ball.setCollideWorldBounds(true);
  ball.setBounce(0.75);
 
  ball.setScale(0.2);
  ball.body.allowGravity = false;


  scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '32px', fill: '#fff' });
  levelText = this.add.text(500, 16, 'Level: 1', { fontSize: '32px', fill: '#fff' });

  for (let i = 0; i < 3; i++) {
    createTarget(this);
  }

  for (let i = 0; i < 3; i++) {
    createObstacle(this);
  }
  // Aggiungi questi due loop subito dopo aver creato i target e gli ostacoli.
  targets.forEach(target => {
    target.body.allowGravity = false;
    this.physics.add.collider(ball, target, function(ball, target) {
      hitTarget(ball, target, this);
    }, null, this);
  });

  obstacles.forEach(obstacle => {
    obstacle.body.allowGravity = false;
    this.physics.add.collider(ball, obstacle, function(ball, obstacle) {
      hitObstacle(ball, obstacle);
    }, null, this);
  });
  this.input.on('pointerdown', function(ptr) {
    if (ball.getBounds().contains(ptr.x, ptr.y)) {
      isDragging = true;
      pointer = ptr;
    }
  }, this);

  this.input.on('pointerup', function() {
    if (isDragging) {
      launchBall();
    }
  }, this);

}

function addColliders(scene) {
  targets.forEach(target => {
    target.body.allowGravity = false;
    scene.physics.add.collider(ball, target, function(ball, target) {
      hitTarget(ball, target, scene);
    }, null, scene);
  });

  obstacles.forEach(obstacle => {
    obstacle.body.allowGravity = false;
    scene.physics.add.collider(ball, obstacle, function(ball, obstacle) {
      hitObstacle(ball, obstacle);
    }, null, scene);
  });
}

    function createTarget(scene) {
      const posX = Phaser.Math.Between(400, 600);
      const posY = Phaser.Math.Between(100, 300);
      const target = scene.physics.add.sprite(posX, posY, 'target');
      target.setScale(0.2);
      target.setCollideWorldBounds(true);
      targets.push(target);
    }

    function createObstacle(scene) {
      const posX = Phaser.Math.Between(300, 500);
      const posY = Phaser.Math.Between(100, 300);
      const obstacle = scene.physics.add.sprite(posX, posY, 'obstacle');
      obstacle.setScale(0.2);
      obstacle.setCollideWorldBounds(true);
      obstacles.push(obstacle);
    }

    function dragBall() {
  // Qui non stiamo effettivamente spostando la pallina, ma solo disegnando la traiettoria o la linea della fionda
  line.setTo(100, 200, pointer.x, pointer.y);
  
  drawTrajectory(trajectory, pointer.x, pointer.y);
}

function launchBall() {
  isDragging = false;
  const currentBall = ball; // Salviamo la referenza alla pallina corrente
  currentBall.body.allowGravity = true;

  let velocity = new Phaser.Math.Vector2(pointer.x - currentBall.x, pointer.y - currentBall.y);
  
  // Scala la velocità
  velocity.scale(-10);

  currentBall.setVelocity(velocity.x, velocity.y);
  trajectory.clear();

  // Dopo aver lanciato la pallina, creiamo una nuova
  createNewBall(scene);

  // Rimuoviamo la pallina corrente dopo 10 secondi se non ha colpito nulla
  setTimeout(() => {
    if (currentBall.active) {
      currentBall.destroy();
    }
  }, 10000);
}


function createNewBall(scene) {
  // Creare una nuova pallina con le stesse proprietà della prima
  const newBall = scene.physics.add.sprite(100, 200, 'ball');

  console.log("Creazione di una nuova pallina");
  newBall.setInteractive();
  newBall.setCollideWorldBounds(true);
  newBall.setBounce(0.75);
  newBall.setScale(0.2);
  newBall.body.allowGravity = false;
  addColliders(scene);
  // aggiungere la nuova pallina all'array delle palline, se hai un array
  // balls.push(newBall);

  // Se vuoi, puoi impostare questa nuova pallina come "ball" per il resto del codice
  ball = newBall;
}


function drawTrajectory(trajectory, x, y) {
  trajectory.clear();
  trajectory.lineStyle(2, 0x00ff00);
  var velocity = new Phaser.Math.Vector2(x - ball.x, y - ball.y); // Rendiamola coerente con la posizione iniziale della pallina
  velocity.scale(-10);
  var timeResolution = 30;
  var timeSlice = 1 / 60;
  var px = ball.x, py = ball.y;
  for (var i = 0; i < timeResolution; i++) {
    px += velocity.x * timeSlice;
    py += velocity.y * timeSlice;
    trajectory.strokeCircle(px, py, 5);
    velocity.y += 300 * timeSlice;
  }
}


function update() {
  if (isDragging) {
    dragBall();
    drawTrajectory(trajectory, pointer.x, pointer.y);
  }
  if (!isDragging && Math.abs(ball.body.velocity.x) < 5 && Math.abs(ball.body.velocity.y) < 5) {
  ball.setPosition(100, 200);
  ball.setVelocity(0, 0);
  ball.body.allowGravity = false;
}

if (shouldReset || (Math.abs(ball.body.velocity.x) < 5 && Math.abs(ball.body.velocity.y) < 5)) {
    resetBall();
    shouldReset = false;
  }
  // Altre logiche del gioco qui
}

 

    function hitTarget(ball, target, scene) {
      score += 10;
      scoreText.setText('Score: ' + score);
      target.destroy();
      targets.splice(targets.indexOf(target), 1);

      scene.tweens.add({
    targets: target,
    alpha: 0,
    duration: 200,
    onComplete: function () {
      target.destroy();
      ball.destroy(); 
    }
  });
  shouldReset = true;
      if (targets.length === 0) {
        levelUp(scene);
      }


    }

    function hitObstacle(ball, obstacle) {
  score -= 10;
  scoreText.setText('Score: ' + score);

  // Aggiunto per distruggere l'ostacolo
  obstacle.destroy();
  obstacles.splice(obstacles.indexOf(obstacle), 1);
  ball.destroy(); 
  shouldReset = true;
}


    function levelUp(scene) {
  level++;
  levelText.setText('Level: ' + level);
  
  // Pulisci vecchi target e ostacoli
  targets.forEach(target => target.destroy());
  obstacles.forEach(obstacle => obstacle.destroy());
  targets = [];
  obstacles = [];

  // Crea nuovi target e ostacoli in base al livello
  for (let i = 0; i < level + 2; i++) {
    createTarget(scene);
  }
  for (let i = 0; i < level + 1; i++) {
    createObstacle(scene);
  }

  // Imposta la gravità a false per nuovi target e ostacoli
  targets.forEach(target => {
    target.body.allowGravity = false;
    scene.physics.add.collider(ball, target, function(ball, target) {
      hitTarget(ball, target, scene);
    }, null, scene);
  });

  obstacles.forEach(obstacle => {
    obstacle.body.allowGravity = false;
    scene.physics.add.collider(ball, obstacle, function(ball, obstacle) {
      hitObstacle(ball, obstacle);
    }, null, scene);
  });

  ball.setX(100);
  ball.setY(300);
  ball.setVelocity(0, 0);
  ball.body.allowGravity = false;

  setTimeout(() => {
    if (targets.length > 0) { // solo se ci sono ancora target
      resetBall();
    }
  }, 2000);
}

function resetBall() {
  ball.setPosition(100, 200);
  ball.setVelocity(0, 0);
  ball.body.allowGravity = false;
}

  </script>
</body>
</html>
